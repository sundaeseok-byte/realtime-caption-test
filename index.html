<!doctype html>

<html lang="ko">

<head>

<meta charset="utf-8" />

<meta name="viewport" content="width=device-width,initial-scale=1" />

<title>실시간 자막 — 타자형 vs 완성형 (가변 분할)</title>

<style>

  :root { --fs: 22px; }

  *{box-sizing:border-box}

  body{margin:0;background:#0b0f14;color:#e9eef5;font:var(--fs)/1.6 "Noto Sans KR",system-ui,sans-serif}

  header{padding:8px;border-bottom:1px solid #1e2a36;display:flex;gap:6px;align-items:center;flex-wrap:wrap}

  button, select, label.switch{padding:6px 10px;border-radius:8px;border:1px solid #1e2a36;background:#111923;color:#e9eef5;cursor:pointer;font-weight:600}

  button.primary{background:#4da3ff;color:#001733;border-color:transparent}

  button.danger{background:#ff4d6d;color:#250008;border-color:transparent}

  select{appearance:none}

  .pill{font-size:12px;color:#9aa3ad}

  #state{margin-left:auto;color:#9aa3ad}



  /* 기본: 실시간 40% / 완성형 60% */

  main{display:grid;grid-template-columns:2fr 3fr;gap:6px;padding:6px}

  /* 분할 비율 프리셋 */

  main[data-split="35-65"]{grid-template-columns:7fr 13fr}

  main[data-split="40-60"]{grid-template-columns:2fr 3fr}

  main[data-split="45-55"]{grid-template-columns:9fr 11fr}

  main[data-split="50-50"]{grid-template-columns:1fr 1fr}



  .col{border:1px solid #1e2a36;border-radius:10px;background:#0e141b;display:flex;flex-direction:column;min-height:54vh}

  .col header{padding:6px 8px;border-bottom:1px solid #1e2a36}

  .title{font-weight:700;color:#9bb2c7;font-size:14px}

  .pane{padding:8px;white-space:pre-wrap;overflow:auto;flex:1}

  .note{font-size:11px;color:#8aa0b4;padding:6px 8px;border-top:1px solid #1e2a36}



  /* 📱 모바일: 위아래 배치 */

  @media (max-width:768px){

    main{grid-template-columns:1fr;gap:4px;padding:4px}

    .col{min-height:42vh}

    .title{font-size:13px}

    .note{font-size:10px}

    header{gap:4px;padding:6px}

    button,select,label.switch{padding:5px 8px}

  }

</style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">🎙️ 시작</button>

    <button id="clear">🧹 지우기</button>

    <button id="copy">📋 복사</button>



    <!-- 보기/분할/컴팩트 -->

    <select id="viewMode" title="보기 모드">

      <option value="split" selected>양쪽 보기</option>

      <option value="live">실시간만</option>

      <option value="final">완성형만</option>

    </select>

    <select id="splitSel" title="분할 비율">

      <option value="35-65">35 : 65</option>

      <option value="40-60" selected>40 : 60</option>

      <option value="45-55">45 : 55</option>

      <option value="50-50">50 : 50</option>

    </select>

    <label class="switch"><input type="checkbox" id="compactToggle" /> 컴팩트</label>



    <!-- 글자 크기 -->

    <button id="smaller" title="글자 작게">A−</button>

    <button id="bigger"  title="글자 크게">A+</button>

    <span id="fsLabel" class="pill"></span>



    <!-- 맞춤법(완성형에만) -->

    <label class="switch" title="완성형에만 적용 (무료 공개 API)">

      <input type="checkbox" id="spellToggle" />

      맞춤법(완성형)

    </label>



    <span id="state">대기</span>

  </header>



  <main id="grid" data-split="40-60">

    <section class="col" id="col-live">

      <header><span class="title">✍️ 실시간 타자형 (append-only)</span></header>

      <div id="livePane" class="pane" aria-live="polite"></div>

      <div class="note">바로 붙는 출력. 찍힌 글자는 수정하지 않습니다.</div>

    </section>



    <section class="col" id="col-final">

      <header><span class="title">✅ 완성형 (중복 억제 + 디바운스)</span></header>

      <div id="finalPane" class="pane"></div>

      <div class="note">0.9초 생각 후 문장 단위로 줄바꿈 저장. 옵션으로 맞춤법 보정.</div>

    </section>

  </main>



<script>

(() => {

  /* ===== 글자 크기 & 컴팩트 & 분할 ===== */

  const FONT_MIN=14,FONT_MAX=64,STEP=2;

  const fsLabel=document.getElementById("fsLabel");

  const compactToggle=document.getElementById("compactToggle");

  const viewModeSel=document.getElementById("viewMode");

  const splitSel=document.getElementById("splitSel");

  const grid=document.getElementById("grid");



  let curFs=Number(localStorage.getItem("subtitle_fs_px")||22);

  function applyFs(px){

    curFs=Math.min(FONT_MAX,Math.max(FONT_MIN,px));

    document.documentElement.style.setProperty("--fs",curFs+"px");

    fsLabel.textContent=`${curFs}px`;

    localStorage.setItem("subtitle_fs_px",String(curFs));

  }

  applyFs(curFs);

  document.getElementById("smaller").onclick=()=>applyFs(curFs-STEP);

  document.getElementById("bigger").onclick =()=>applyFs(curFs+STEP);



  compactToggle.addEventListener('change',()=>document.body.classList.toggle('compact',compactToggle.checked));

  function applyViewMode(m){

    const live=document.getElementById('col-live');

    const fin =document.getElementById('col-final');

    if(m==='live'){live.style.display='flex';fin.style.display='none';}

    else if(m==='final'){live.style.display='none';fin.style.display='flex';}

    else {live.style.display='flex';fin.style.display='flex';}

  }

  applyViewMode(viewModeSel.value);

  viewModeSel.addEventListener('change',()=>applyViewMode(viewModeSel.value));



  function applySplit(v){ grid.setAttribute('data-split',v); localStorage.setItem('subtitle_split',v); }

  applySplit(localStorage.getItem('subtitle_split')||splitSel.value);

  splitSel.value = grid.getAttribute('data-split');

  splitSel.addEventListener('change',()=>applySplit(splitSel.value));



  /* ===== 음성 인식 ===== */

  const Rec=window.SpeechRecognition||window.webkitSpeechRecognition;

  if(!Rec){document.body.innerHTML="<p style='padding:16px'>❌ 이 브라우저는 Web Speech API 미지원. Chrome/삼성 인터넷을 사용하세요.</p>";return;}

  const r=new Rec(); r.lang="ko-KR"; r.continuous=true; r.interimResults=true; r.maxAlternatives=1;



  const toggle=document.getElementById("toggle");

  const clearBtn=document.getElementById("clear");

  const copyBtn=document.getElementById("copy");

  const state=document.getElementById("state");

  const livePane=document.getElementById("livePane");

  const finalPane=document.getElementById("finalPane");

  const spellToggle=document.getElementById("spellToggle");

  let recognizing=false;



  /* ===== 좌측: 실시간 append-only ===== */

  const liveNode=document.createTextNode(""); livePane.appendChild(liveNode);

  let liveCurrentStream=""; let liveQueuedDelta=""; let liveFlushTimer=null; let liveLastFlushAt=0;

  const LIVE_THROTTLE_MS=220;

  function commonPrefixLen(a,b){const n=Math.min(a.length,b.length);let i=0;while(i<n&&a.charCodeAt(i)===b.charCodeAt(i))i++;return i;}

  function liveScheduleAppend(newStream){

    const cpl=commonPrefixLen(liveCurrentStream,newStream);

    const delta=newStream.slice(cpl);

    if(!delta) return;

    liveQueuedDelta+=delta;

    const now=performance.now();

    const due=Math.max(0,LIVE_THROTTLE_MS-(now-liveLastFlushAt));

    if(!liveFlushTimer) liveFlushTimer=setTimeout(liveFlush,due);

    liveCurrentStream=newStream;

  }

  function liveFlush(){

    if(liveQueuedDelta){

      liveNode.data+=liveQueuedDelta;

      livePane.scrollTop=livePane.scrollHeight;

      liveQueuedDelta="";

    }

    liveLastFlushAt=performance.now(); liveFlushTimer=null;

  }



  /* ===== 우측: 완성형 (디바운스+중복 억제+맞춤법 옵션) ===== */

  const finalNode=document.createTextNode(""); finalPane.appendChild(finalNode);

  let pendingFinal=""; let debounceTimer=null;

  const DEBOUNCE_MS=900; let lastFinalNorm=""; let lastFinalAt=0; const FINAL_DEDUP_MS=1000;

  function norm(s){return (s||"").replace(/\s+/g," ").replace(/[.,!?…！？。~]+$/g,"").trim().toLowerCase();}

  function appendFinalLine(line){

    if(!line) return;

    finalNode.data+=(finalNode.data && !/\n$/.test(finalNode.data)?"\n":"")+line;

    finalPane.scrollTop=finalPane.scrollHeight;

  }

  async function grammarCheckKo(text,timeoutMs=1500){

    if(!spellToggle.checked) return text;

    const controller=new AbortController(); const to=setTimeout(()=>controller.abort(),timeoutMs);

    try{

      const res=await fetch("https://api.languagetool.org/v2/check",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({language:"ko",text}),signal:controller.signal});

      clearTimeout(to);

      if(!res.ok) throw new Error("HTTP "+res.status);

      const data=await res.json(); let out=text; const matches=(data.matches||[]).sort((a,b)=>b.offset-a.offset);

      for(const m of matches){const rep=(m.replacements&&m.replacements[0]?.value)||null; if(!rep) continue; out=out.slice(0,m.offset)+rep+out.slice(m.offset+m.length);}

      return out;

    }catch{clearTimeout(to);return text;}

  }

  function commitFinalNow(txt){

    const src=txt.trim(); if(!src) return;

    grammarCheckKo(src).then(fixed=>{appendFinalLine(fixed); pendingFinal="";});

  }



  /* ===== 이벤트 ===== */

  r.onresult=(e)=>{

    let interim="", finals=[];

    for(let i=e.resultIndex;i<e.results.length;i++){

      const seg=e.results[i][0].transcript;

      if(e.results[i].isFinal){

        const now=performance.now(); const n=norm(seg);

        if(n && n===lastFinalNorm && (now-lastFinalAt)<FINAL_DEDUP_MS) continue;

        lastFinalNorm=n; lastFinalAt=now; finals.push(seg);

      } else interim+=seg;

    }

    if(interim) liveScheduleAppend(interim);

    if(finals.length){

      pendingFinal=finals[finals.length-1];

      if(debounceTimer) clearTimeout(debounceTimer);

      debounceTimer=setTimeout(()=>commitFinalNow(pendingFinal),DEBOUNCE_MS);

      liveCurrentStream="";

    }

  };

  r.onstart=()=>{state.textContent="🎤 인식 중";toggle.textContent="⏸️ 중지";toggle.className="danger";};

  r.onend=()=>{if(recognizing){try{r.start();}catch{}}else{state.textContent="대기";toggle.textContent="🎙️ 시작";toggle.className="primary";}};

  r.onerror=e=>appendFinalLine(`(오류:${e.error})`);



  toggle.onclick=async()=>{

    if(!recognizing){

      try{const s=await navigator.mediaDevices.getUserMedia({audio:true});s.getTracks().forEach(t=>t.stop());}

      catch{alert("마이크 권한이 필요합니다.");return;}

      recognizing=true; r.start();

    } else { recognizing=false; r.stop(); }

  };

  clearBtn.onclick=()=>{

    liveNode.data=""; finalNode.data=""; liveCurrentStream=""; liveQueuedDelta="";

    if(liveFlushTimer){clearTimeout(liveFlushTimer); liveFlushTimer=null;}

    pendingFinal=""; if(debounceTimer){clearTimeout(debounceTimer); debounceTimer=null;}

  };

  copyBtn.onclick=async()=>{

    const both=`[실시간]\n${liveNode.data}\n\n[완성형]\n${finalNode.data}`;

    try{await navigator.clipboard.writeText(both); state.textContent="복사됨"; setTimeout(()=>state.textContent=recognizing?"🎤 인식 중":"대기",900);}

    catch{alert("복사 실패");}

  };

})();

</script>

</body>

</html>