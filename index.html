<!doctype html>

<html lang="ko">

<head>

<meta charset="utf-8" />

<meta name="viewport" content="width=device-width,initial-scale=1" />

<title>ì‹¤ì‹œê°„ ìë§‰ â€” íƒ€ìí˜• vs ì™„ì„±í˜•</title>

<style>

  :root { --fs: 22px; }

  *{box-sizing:border-box}

  body{margin:0;background:#0b0f14;color:#e9eef5;font:var(--fs)/1.6 "Noto Sans KR",system-ui,sans-serif}

  header{padding:10px;border-bottom:1px solid #1e2a36;display:flex;gap:8px;align-items:center;flex-wrap:wrap}

  button{padding:6px 12px;border-radius:8px;border:1px solid #1e2a36;background:#111923;color:#e9eef5;cursor:pointer;font-weight:600}

  button.primary{background:#4da3ff;color:#001733;border-color:transparent}

  button.danger{background:#ff4d6d;color:#250008;border-color:transparent}

  .group{display:flex;gap:6px;align-items:center}

  .pill{font-size:12px;color:#9aa3ad}

  main{display:grid;grid-template-columns:1fr 1fr;gap:10px;padding:10px}

  .col{border:1px solid #1e2a36;border-radius:14px;background:#0e141b;display:flex;flex-direction:column;min-height:70vh}

  .col header{padding:8px 12px;border-bottom:1px solid #1e2a36;display:flex;justify-content:space-between;align-items:center}

  .title{font-weight:700;color:#9bb2c7}

  .pane{padding:12px;white-space:pre-wrap;overflow:auto;flex:1}

  .note{font-size:12px;color:#8aa0b4;padding:8px 12px;border-top:1px solid #1e2a36}

  #state{margin-left:auto;color:#9aa3ad}

  .switch{display:flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid #1e2a36;border-radius:8px;background:#111923}

  @media (max-width: 800px){ main{grid-template-columns:1fr} }

</style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">ğŸ™ï¸ ì‹œì‘</button>

    <button id="clear">ğŸ§¹ ì§€ìš°ê¸°</button>

    <button id="copy">ğŸ“‹ ë‘ íŒ¨ë„ ë³µì‚¬</button>



    <div class="group">

      <button id="smaller" title="ê¸€ì ì‘ê²Œ">Aâˆ’</button>

      <button id="bigger"  title="ê¸€ì í¬ê²Œ">A+</button>

      <span id="fsLabel" class="pill"></span>

    </div>



    <label class="switch" title="ì™„ì„±í˜•ì—ë§Œ ì ìš©ë©ë‹ˆë‹¤ (ë¬´ë£Œ ê³µê°œ API, ëŠë¦´ ìˆ˜ ìˆìŒ)">

      <input type="checkbox" id="spellToggle" />

      ë§ì¶¤ë²• ë³´ì •(ì™„ì„±í˜•)

    </label>



    <span id="state">ëŒ€ê¸°</span>

  </header>



  <main>

    <section class="col" id="col-live">

      <header><span class="title">âœï¸ ì‹¤ì‹œê°„ íƒ€ìí˜• (append-only)</span></header>

      <div id="livePane" class="pane" aria-live="polite"></div>

      <div class="note">ë°”ë¡œë°”ë¡œ ë¶™ëŠ” ì¶œë ¥. ì´ë¯¸ ì°íŒ ê¸€ìëŠ” ì ˆëŒ€ ìˆ˜ì •í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>

    </section>



    <section class="col" id="col-final">

      <header><span class="title">âœ… ì™„ì„±í˜• (ì¤‘ë³µ ì–µì œ + ë””ë°”ìš´ìŠ¤)</span></header>

      <div id="finalPane" class="pane"></div>

      <div class="note">ì ê¹ ìƒê°í•œ ë’¤(ì•½ 0.9ì´ˆ) í•œ ë¬¸ì¥ì”© í™•ì •í•´ ì¤„ë°”ê¿ˆìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.</div>

    </section>

  </main>



<script>

(() => {

  /* ============ ê¸€ì í¬ê¸° ============ */

  const FONT_MIN=16, FONT_MAX=64, STEP=2;

  const fsLabel = document.getElementById("fsLabel");

  let curFs = Number(localStorage.getItem("subtitle_fs_px") || 22);

  function applyFs(px){

    curFs = Math.min(FONT_MAX, Math.max(FONT_MIN, px));

    document.documentElement.style.setProperty("--fs", curFs + "px");

    fsLabel.textContent = `${curFs}px`;

    localStorage.setItem("subtitle_fs_px", String(curFs));

  }

  applyFs(curFs);

  document.getElementById("smaller").onclick = () => applyFs(curFs - STEP);

  document.getElementById("bigger").onclick  = () => applyFs(curFs + STEP);



  /* ============ ìŒì„± ì¸ì‹ ============ */

  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (!Rec){

    document.body.innerHTML = "<p style='padding:16px'>âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” Web Speech APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome/ì‚¼ì„± ì¸í„°ë„·ì„ ì‚¬ìš©í•˜ì„¸ìš”.</p>";

    return;

  }

  const r = new Rec();

  r.lang = "ko-KR";

  r.continuous = true;

  r.interimResults = true;

  r.maxAlternatives = 1;



  const toggle = document.getElementById("toggle");

  const clearBtn= document.getElementById("clear");

  const copyBtn = document.getElementById("copy");

  const state   = document.getElementById("state");

  const livePane= document.getElementById("livePane");

  const finalPane= document.getElementById("finalPane");

  const spellToggle = document.getElementById("spellToggle");



  let recognizing = false;



  /* ============ ì¢Œì¸¡: ì‹¤ì‹œê°„ íƒ€ìí˜• (append-only) ============ */

  const liveNode = document.createTextNode("");

  livePane.appendChild(liveNode);



  let liveCurrentStream = ""; // ì—”ì§„ì´ ë³´ëŠ” ìµœì‹  ì„ì‹œ ë¬¸ìì—´

  let liveQueuedDelta   = ""; // ì•„ì§ ì¶œë ¥ ì•ˆ í•œ ê¼¬ë¦¬

  let liveFlushTimer = null;

  let liveLastFlushAt = 0;

  const LIVE_THROTTLE_MS = 220; // â³ íƒ€ì ì†ë„ (ì›í•˜ë©´ 280~400ìœ¼ë¡œ ë” ëŠë¦¬ê²Œ)



  function commonPrefixLen(a,b){

    const n = Math.min(a.length, b.length);

    let i=0; while (i<n && a.charCodeAt(i)===b.charCodeAt(i)) i++; return i;

  }

  function liveScheduleAppend(newStream){

    const cpl = commonPrefixLen(liveCurrentStream, newStream);

    const delta = newStream.slice(cpl);

    if (!delta) return;

    liveQueuedDelta += delta;



    const now = performance.now();

    const due = Math.max(0, LIVE_THROTTLE_MS - (now - liveLastFlushAt));

    if (!liveFlushTimer) liveFlushTimer = setTimeout(liveFlush, due);

    liveCurrentStream = newStream; // í™”ë©´ì€ append-only, ë‚´ë¶€ ìŠ¤ëƒ…ìƒ·ë§Œ êµì²´

  }

  function liveFlush(){

    if (liveQueuedDelta){

      liveNode.data += liveQueuedDelta; // êµì²´ ì—†ì´ ë§ë¶™ì„

      livePane.scrollTop = livePane.scrollHeight;

      liveQueuedDelta = "";

    }

    liveLastFlushAt = performance.now();

    liveFlushTimer = null;

  }



  /* ============ ìš°ì¸¡: ì™„ì„±í˜• (ì¤‘ë³µ ì–µì œ + ë””ë°”ìš´ìŠ¤ + ì„ íƒì  ë§ì¶¤ë²•) ============ */

  const finalNode = document.createTextNode("");

  finalPane.appendChild(finalNode);



  // final ë””ë°”ìš´ìŠ¤ & ì¤‘ë³µ ì–µì œ

  let pendingFinal = "";           // ìµœê·¼ ìˆ˜ì§‘ëœ final í›„ë³´

  let debounceTimer = null;

  const DEBOUNCE_MS = 900;         // ì ê¹ ê¸°ë‹¤ë ¸ë‹¤ê°€ í•œ ë²ˆë§Œ í™•ì •

  let lastFinalNorm = "";          // ì§§ì€ ì‹œê°„ ë‚´ ë™ì¼ ë¬¸ì¥ ë¬´ì‹œ

  let lastFinalAt   = 0;

  const FINAL_DEDUP_MS = 1000;



  function norm(s){ return (s||"").replace(/\s+/g," ").replace(/[.,!?â€¦ï¼ï¼Ÿã€‚~]+$/g,"").trim().toLowerCase(); }



  // ì™„ì„±í˜•ì— ì¤„ë°”ê¿ˆìœ¼ë¡œ ì¶”ê°€

  function appendFinalLine(line){

    if (!line) return;

    finalNode.data += (finalNode.data && !/\n$/.test(finalNode.data) ? "\n" : "") + line;

    finalPane.scrollTop = finalPane.scrollHeight;

  }



  // ê³µê°œ LanguageToolë¡œ ê°„ë‹¨ ë³´ì • (ì‹¤íŒ¨í•˜ë©´ ì›ë¬¸ ì‚¬ìš©)

  async function grammarCheckKo(text, timeoutMs = 1500){

    if (!spellToggle.checked) return text;

    const controller = new AbortController();

    const to = setTimeout(()=>controller.abort(), timeoutMs);

    try{

      const res = await fetch("https://api.languagetool.org/v2/check", {

        method: "POST",

        headers: {"Content-Type":"application/x-www-form-urlencoded"},

        body: new URLSearchParams({ language:"ko", text }),

        signal: controller.signal

      });

      clearTimeout(to);

      if (!res.ok) throw new Error("HTTP "+res.status);

      const data = await res.json();

      let out = text;

      const matches = (data.matches || []).sort((a,b)=> (b.offset - a.offset));

      for (const m of matches){

        const rep = (m.replacements && m.replacements[0]?.value) || null;

        if (!rep) continue;

        const start = m.offset, end = m.offset + m.length;

        out = out.slice(0,start) + rep + out.slice(end);

      }

      return out;

    }catch{

      clearTimeout(to);

      return text;

    }

  }



  function commitFinalNow(txt){

    const src = txt.trim();

    if (!src) return;

    grammarCheckKo(src).then(fixed => {

      appendFinalLine(fixed);

      pendingFinal = "";

    });

  }



  /* ============ ì¸ì‹ ì´ë²¤íŠ¸ ============ */

  r.onresult = (e) => {

    let interim = "";

    let finals  = [];



    for (let i=e.resultIndex; i<e.results.length; i++){

      const seg = e.results[i][0].transcript;

      if (e.results[i].isFinal) {

        const now = performance.now();

        const n = norm(seg);

        if (n && n===lastFinalNorm && (now-lastFinalAt)<FINAL_DEDUP_MS) continue; // ë¹ ë¥¸ ì¤‘ë³µ ì°¨ë‹¨

        lastFinalNorm = n; lastFinalAt = now;

        finals.push(seg);

      } else {

        interim += seg;

      }

    }



    // ì¢Œì¸¡ ì‹¤ì‹œê°„: interimì„ ë¸íƒ€ë¡œ ì¦‰ì‹œ(íƒ€ìì†ë„ë¡œ) ë¶™ì„

    if (interim) liveScheduleAppend(interim);



    // ìš°ì¸¡ ì™„ì„±í˜•: finalì„ ë””ë°”ìš´ìŠ¤ í›„ í•œ ë²ˆë§Œ í™•ì •

    if (finals.length){

      pendingFinal = finals[finals.length-1];

      if (debounceTimer) clearTimeout(debounceTimer);

      debounceTimer = setTimeout(()=> commitFinalNow(pendingFinal), DEBOUNCE_MS);

      // ì¢Œì¸¡ ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼ì€ ë‹¤ìŒ ë¬¸ì¥ ëŒ€ë¹„ ì´ˆê¸°í™”(í™”ë©´ì€ ìœ ì§€, ë‚´ë¶€ ìŠ¤ëƒ…ìƒ·ë§Œ ë¦¬ì…‹)

      liveCurrentStream = "";

    }

  };



  r.onstart = () => { state.textContent="ğŸ¤ ì¸ì‹ ì¤‘"; toggle.textContent="â¸ï¸ ì¤‘ì§€"; toggle.className="danger"; };

  r.onend = () => {

    if (recognizing) { try{ r.start(); }catch{} }

    else { state.textContent="ëŒ€ê¸°"; toggle.textContent="ğŸ™ï¸ ì‹œì‘"; toggle.className="primary"; }

  };

  r.onerror = (e) => {

    // ì˜¤ë¥˜ëŠ” ë‘ íŒ¨ë„ ì¤‘ ìš°ì¸¡ì—ë§Œ ë‚¨ê¹€

    appendFinalLine(`(ì˜¤ë¥˜: ${e.error})`);

  };



  toggle.onclick = async () => {

    if (!recognizing){

      try{

        const s = await navigator.mediaDevices.getUserMedia({audio:true});

        s.getTracks().forEach(t=>t.stop());

      }catch{

        alert("ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.");

        return;

      }

      recognizing = true; r.start();

    }else{

      recognizing = false; r.stop();

    }

  };



  clearBtn.onclick = () => {

    liveNode.data = "";

    finalNode.data = "";

    liveCurrentStream = "";

    liveQueuedDelta = "";

    if (liveFlushTimer){ clearTimeout(liveFlushTimer); liveFlushTimer=null; }

    pendingFinal = "";

    if (debounceTimer){ clearTimeout(debounceTimer); debounceTimer=null; }

  };



  copyBtn.onclick = async () => {

    const both = `[ì‹¤ì‹œê°„]\n${liveNode.data}\n\n[ì™„ì„±í˜•]\n${finalNode.data}`;

    try{

      await navigator.clipboard.writeText(both);

      state.textContent = "ë³µì‚¬ë¨";

      setTimeout(()=> state.textContent = recognizing ? "ğŸ¤ ì¸ì‹ ì¤‘" : "ëŒ€ê¸°", 900);

    }catch{ alert("ë³µì‚¬ ì‹¤íŒ¨"); }

  };

})();

</script>

</body>

</html>