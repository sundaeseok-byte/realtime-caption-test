<!doctype html>

<html lang="ko">

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>ì‹¤ì‹œê°„ í•œêµ­ì–´ ìë§‰ (append-only + ë§ì¶¤ë²• ë³´ì • ì˜µì…˜)</title>

  <style>

    :root { --fs: 22px; }

    body { margin:0; background:#111; color:#eee; font:var(--fs)/1.6 "Noto Sans KR",sans-serif; }

    header { padding:10px; border-bottom:1px solid #444; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    button { padding:6px 14px; border-radius:6px; border:none; cursor:pointer; font-weight:600; }

    button.primary { background:#4da3ff; color:#000; }

    button.danger  { background:#ff4d6d; color:#000; }

    #live { padding:8px 12px; color:#9aa3ad; font-style:italic; min-height:1.6em; }

    #screen { padding:12px; height:70vh; overflow-y:auto; white-space:pre-wrap; }

    #state { margin-left:auto; color:#aaa; }

    .group { display:flex; gap:6px; align-items:center; }

    .pill  { font-size:12px; color:#9aa3ad; }

    label.switch { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #444; border-radius:8px; }

  </style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">ğŸ™ï¸ ì‹œì‘</button>

    <button id="clear">ğŸ§¹ ì§€ìš°ê¸°</button>

    <button id="copy">ğŸ“‹ ë³µì‚¬</button>



    <div class="group" aria-label="ê¸€ì í¬ê¸° ì¡°ì ˆ">

      <button id="smaller" title="ê¸€ì ì‘ê²Œ">Aâˆ’</button>

      <button id="bigger"  title="ê¸€ì í¬ê²Œ">A+</button>

      <span id="fsLabel" class="pill"></span>

    </div>



    <label class="switch" title="í™•ì • ì‹œì ì—ë§Œ ë§ì¶¤ë²• ë³´ì •í•´ì„œ ì¶”ê°€ (ê³¼ê±° í…ìŠ¤íŠ¸ëŠ” ìˆ˜ì • ì•ˆ í•¨)">

      <input type="checkbox" id="spellToggle" />

      ë§ì¶¤ë²• ë³´ì •(ìµœì¢…ë§Œ)

    </label>



    <span id="state">ëŒ€ê¸°</span>

  </header>



  <div id="live" aria-live="polite"></div>

  <div id="screen"></div>



<script>

(() => {

  /* ===== ê¸€ì í¬ê¸° ===== */

  const FONT_MIN=16, FONT_MAX=64, STEP=2;

  const fsLabel = document.getElementById("fsLabel");

  let curFs = Number(localStorage.getItem("subtitle_fs_px") || 22);

  function applyFs(px){

    curFs = Math.min(FONT_MAX, Math.max(FONT_MIN, px));

    document.documentElement.style.setProperty("--fs", curFs + "px");

    fsLabel.textContent = `${curFs}px`;

    localStorage.setItem("subtitle_fs_px", String(curFs));

  }

  applyFs(curFs);

  document.getElementById("smaller").onclick = () => applyFs(curFs - STEP);

  document.getElementById("bigger").onclick  = () => applyFs(curFs + STEP);



  /* ===== ìŒì„± ì¸ì‹ ===== */

  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (!Rec) {

    document.body.innerHTML = "<p style='padding:16px'>âŒ í¬ë¡¬/ì‚¼ì„± ì¸í„°ë„· ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤í–‰í•´ì£¼ì„¸ìš”.</p>";

    return;

  }



  const r = new Rec();

  r.lang = "ko-KR";

  r.continuous = true;

  r.interimResults = true;

  r.maxAlternatives = 1;



  const toggle = document.getElementById("toggle");

  const clearBtn= document.getElementById("clear");

  const copyBtn = document.getElementById("copy");

  const state   = document.getElementById("state");

  const screen  = document.getElementById("screen");

  const live    = document.getElementById("live");

  const spellToggle = document.getElementById("spellToggle");



  let recognizing = false;



  // ë³¸ë¬¸ì€ append-only í…ìŠ¤íŠ¸ ë…¸ë“œ(ê¹œë¹¡ì„ ë°©ì§€)

  const tape = document.createTextNode("");

  screen.appendChild(tape);



  // ì§„í–‰ì¤‘ ìŠ¤íŠ¸ë¦¼(ì—”ì§„ì˜ ìµœì‹  ìŠ¤ëƒ…ìƒ·)

  let currentStream = "";

  let queuedDelta = "";



  // í‘œì‹œ ì†ë„

  const THROTTLE_MS = 380;

  let lastFlushAt = 0, flushTimer = null;



  // ì¤‘ë³µ final ì–µì œ(ê°™ì€ ë¬¸ì¥ ì—°íƒ€ ë°©ì§€)

  let lastFinalNorm = "";

  let lastFinalAt   = 0;

  const FINAL_DEDUP_MS = 1000;



  function norm(s){ return (s||"").replace(/\s+/g," ").trim().toLowerCase(); }



  function commonPrefixLen(a,b){

    const n = Math.min(a.length, b.length);

    let i=0; while (i<n && a.charCodeAt(i)===b.charCodeAt(i)) i++; return i;

  }



  function scheduleAppendFrom(newStream){

    const cpl = commonPrefixLen(currentStream, newStream);

    const delta = newStream.slice(cpl);

    if (!delta) return;

    queuedDelta += delta;



    const now = performance.now();

    const due = Math.max(0, THROTTLE_MS - (now - lastFlushAt));

    if (!flushTimer) flushTimer = setTimeout(flush, due);

    currentStream = newStream;

  }



  function flush(){

    if (queuedDelta) {

      tape.data += queuedDelta;

      screen.scrollTop = screen.scrollHeight;

      queuedDelta = "";

    }

    lastFlushAt = performance.now();

    flushTimer = null;

  }



  /* ===== LanguageTool ë§ì¶¤ë²• ê²€ì‚¬ (ìµœì¢…ë§Œ) =====

     ê³µê°œ API: https://api.languagetool.org/v2/check (ìš”ì²­ ì œí•œ/ì§€ì—° ê°€ëŠ¥)

     ì‹¤íŒ¨ ì‹œ ì›ë¬¸ ê·¸ëŒ€ë¡œ ì“´ë‹¤(í´ë°±). */

  async function grammarCheckKo(text, timeoutMs = 1500){

    const controller = new AbortController();

    const to = setTimeout(()=>controller.abort(), timeoutMs);

    try{

      const res = await fetch("https://api.languagetool.org/v2/check", {

        method: "POST",

        headers: { "Content-Type":"application/x-www-form-urlencoded" },

        body: new URLSearchParams({ language:"ko", text }),

        signal: controller.signal

      });

      clearTimeout(to);

      if (!res.ok) throw new Error("HTTP "+res.status);

      const data = await res.json();

      // ì œì•ˆ ì ìš©

      let out = text;

      // matchesëŠ” ë’¤ì—ì„œ ì•ìœ¼ë¡œ ì ìš©í•´ì•¼ ì¸ë±ìŠ¤ ì•ˆ ê¹¨ì§

      const matches = (data.matches || []).sort((a,b)=> (b.offset - a.offset));

      for (const m of matches){

        const rep = (m.replacements && m.replacements[0]?.value) || null;

        if (!rep) continue;

        const start = m.offset, end = m.offset + m.length;

        out = out.slice(0,start) + rep + out.slice(end);

      }

      return out;

    }catch(_){

      clearTimeout(to);

      return text; // ì‹¤íŒ¨í•˜ë©´ ì›ë¬¸ ìœ ì§€

    }

  }



  r.onresult = async (e) => {

    let interim = "";

    let finals  = [];



    for (let i=e.resultIndex; i<e.results.length; i++){

      const seg = e.results[i][0].transcript;

      if (e.results[i].isFinal) {

        const now = performance.now();

        const n = norm(seg);

        if (n && n===lastFinalNorm && (now-lastFinalAt)<FINAL_DEDUP_MS) continue;

        lastFinalNorm = n; lastFinalAt = now;

        finals.push(seg);

      } else {

        interim += seg;

      }

    }



    // ëª¨ë“œ: ë³´ì • OFF â†’ ì¸í„°ë¦¼ë„ ë³¸ë¬¸ì— append-only

    if (!spellToggle.checked) {

      live.textContent = ""; // ë¼ì´ë¸Œ ì˜ì—­ ë¯¸ì‚¬ìš©

      if (interim) scheduleAppendFrom(interim);

      if (finals.length) currentStream = "";

      return;

    }



    // ëª¨ë“œ: ë³´ì • ON â†’ ì¸í„°ë¦¼ì€ ë¼ì´ë¸Œ ì˜ì—­ì—ë§Œ, ë³¸ë¬¸ì€ final í™•ì • í›„ ë³´ì • ì ìš©í•´ append

    if (interim) {

      live.textContent = interim;

    } else {

      live.textContent = "";

    }



    if (finals.length){

      // ì—¬ëŸ¬ finalì´ í•œêº¼ë²ˆì— ì˜¤ë©´ ë§ˆì§€ë§‰ ë¬¸ì¥ë§Œ ì‚¬ìš© (ê°€ì¥ ìµœì‹ )

      const raw = finals[finals.length-1].trim();

      if (raw) {

        const fixed = await grammarCheckKo(raw);

        // ë³¸ë¬¸ì— ìƒˆë¡œ ì¶”ê°€(append-only, ê³¼ê±° í…ìŠ¤íŠ¸ëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ). ê³µë°±ìœ¼ë¡œ êµ¬ë¶„

        tape.data += (tape.data && !/\s$/.test(tape.data) ? " " : "") + fixed + " ";

        screen.scrollTop = screen.scrollHeight;

      }

      currentStream = "";

      live.textContent = "";

    }

  };



  r.onstart = () => { state.textContent="ğŸ¤ ì¸ì‹ ì¤‘"; toggle.textContent="â¸ï¸ ì¤‘ì§€"; toggle.className="danger"; };

  r.onend = () => {

    if (recognizing) { try { r.start(); } catch {} }

    else { state.textContent="ëŒ€ê¸°"; toggle.textContent="ğŸ™ï¸ ì‹œì‘"; toggle.className="primary"; }

  };

  r.onerror = (e) => {

    tape.data += `(ì˜¤ë¥˜:${e.error}) `;

  };



  toggle.onclick = async () => {

    if (!recognizing) {

      try { const s = await navigator.mediaDevices.getUserMedia({audio:true}); s.getTracks().forEach(t=>t.stop()); }

      catch { alert("ë§ˆì´í¬ ê¶Œí•œ í•„ìš”"); return; }

      recognizing = true; r.start();

    } else { recognizing = false; r.stop(); }

  };



  clearBtn.onclick = () => {

    tape.data=""; currentStream=""; queuedDelta="";

    live.textContent="";

    if (flushTimer){ clearTimeout(flushTimer); flushTimer=null; }

  };

  copyBtn.onclick  = async () => {

    try { await navigator.clipboard.writeText(tape.data); state.textContent="ë³µì‚¬ë¨"; setTimeout(()=>state.textContent=recognizing?"ğŸ¤ ì¸ì‹ ì¤‘":"ëŒ€ê¸°",900); }

    catch { alert("ë³µì‚¬ ì‹¤íŒ¨"); }

  };

})();

</script>

</body>

</html>