<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì‹¤ì‹œê°„ ìë§‰ (í•œêµ­ì–´ Â· ë¬´ë£Œ Â· í•œ íŒŒì¼)</title>
  <style>
    :root { --bg:#0b0f14; --fg:#e9eef5; --muted:#8aa0b4; --accent:#4da3ff; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--fg); font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Noto Sans KR, Arial, sans-serif; }
    header { padding:14px 16px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; border-bottom:1px solid #1c2733; }
    h1 { font-size:16px; margin:0 8px 0 0; color:var(--muted); font-weight:600; }
    button, select { background:#111923; color:var(--fg); border:1px solid #1f2a36; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; }
    button:hover { border-color:#2a3a4c; }
    button.primary { background:var(--accent); color:#001733; border-color:transparent; }
    button.danger { background:#ff4d6d; color:#250008; border-color:transparent; }
    #status { margin-left:auto; font-size:13px; color:var(--muted); display:flex; align-items:center; gap:6px; }
    #lamp { width:10px; height:10px; border-radius:50%; background:#485a6c; display:inline-block; }
    #lamp.on { background:#27d07d; box-shadow:0 0 0 3px rgba(39,208,125,0.15); }
    main { padding:12px; }
    #screen { width:100%; height:65vh; padding:16px; border:1px solid #1f2a36; border-radius:16px; background:#0e141b; overflow:auto; white-space:pre-wrap; }
    #caret { opacity:.6; }
    footer { display:flex; gap:8px; flex-wrap:wrap; padding:12px; border-top:1px solid #1c2733; }
    .pill { font-size:12px; color:var(--muted); }
    .sr { position:absolute; left:-9999px; }
  </style>
</head>
<body>
  <header>
    <h1>ì‹¤ì‹œê°„ ìë§‰</h1>
    <button id="toggle" class="primary" aria-pressed="false">ğŸ™ï¸ ì‹œì‘</button>
    <button id="clear" title="í™”ë©´ ì§€ìš°ê¸°">ğŸ§¹ ì§€ìš°ê¸°</button>
    <button id="copy" title="í´ë¦½ë³´ë“œë¡œ ë³µì‚¬">ğŸ“‹ ë³µì‚¬</button>
    <button id="save" title="íŒŒì¼ë¡œ ì €ì¥">ğŸ’¾ ì €ì¥</button>
    <select id="fontsize" title="ê¸€ì í¬ê¸°">
      <option value="18">ê¸€ì 18</option>
      <option value="22" selected>ê¸€ì 22</option>
      <option value="28">ê¸€ì 28</option>
      <option value="36">ê¸€ì 36</option>
      <option value="48">ê¸€ì 48</option>
    </select>
    <label class="pill"><input type="checkbox" id="timestamp" /> íƒ€ì„ìŠ¤íƒ¬í”„</label>
    <label class="pill"><input type="checkbox" id="autoscroll" checked /> ìë™ ìŠ¤í¬ë¡¤</label>
    <div id="status"><span id="lamp" aria-hidden="true"></span><span id="stateText">ëŒ€ê¸°</span></div>
  </header>

  <main>
    <div id="screen" aria-live="polite" aria-atomic="false"></div>
  </main>

  <footer>
    <small class="pill">Tip: ì‹œì‘ í›„ ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•˜ì„¸ìš”. ì¸ì‹ì´ ë©ˆì¶”ë©´ ìë™ ì¬ì‹œì‘í•©ë‹ˆë‹¤.</small>
  </footer>

<script>
(() => {
  const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
  const scr = document.getElementById('screen');
  const btn = document.getElementById('toggle');
  const clearBtn = document.getElementById('clear');
  const copyBtn = document.getElementById('copy');
  const saveBtn = document.getElementById('save');
  const fsSel = document.getElementById('fontsize');
  const tsChk = document.getElementById('timestamp');
  const autoChk = document.getElementById('autoscroll');
  const lamp = document.getElementById('lamp');
  const stateText = document.getElementById('stateText');

  if (!SpeechRec) {
    scr.textContent = 'ì´ ë¸Œë¼ìš°ì €ëŠ” Web Speech APIë¥¼ ì§€ì›í•˜ì§€ ì•Šì•„ìš”. í¬ë¡¬/ì‚¼ì„± ì¸í„°ë„· ìµœì‹  ë²„ì „ì„ ì‚¬ìš©í•´ ì£¼ì„¸ìš”.';
    btn.disabled = true;
    return;
  }

  let recognizing = false;
  let interimSpan = null;
  let rec = null;

  function nowTS() {
    const d = new Date();
    return `[${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}:${d.getSeconds().toString().padStart(2,'0')}] `;
  }

  function appendText(text, isFinal=false) {
    if (isFinal) {
      const line = (tsChk.checked ? nowTS() : '') + text.trim();
      scr.append(document.createTextNode(line + '\n'));
      if (interimSpan) { interimSpan.remove(); interimSpan = null; }
    } else {
      if (!interimSpan) {
        interimSpan = document.createElement('span');
        interimSpan.id = 'caret';
        interimSpan.style.opacity = '.7';
        interimSpan.style.fontStyle = 'italic';
        scr.append(interimSpan);
      }
      interimSpan.textContent = text;
    }
    if (autoChk.checked) scr.scrollTop = scr.scrollHeight;
  }

  function setUI(on) {
    recognizing = on;
    btn.textContent = on ? 'â¸ï¸ ì¼ì‹œì •ì§€' : 'ğŸ™ï¸ ì‹œì‘';
    btn.classList.toggle('primary', !on);
    btn.classList.toggle('danger', on);
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    lamp.classList.toggle('on', on);
    stateText.textContent = on ? 'ì¸ì‹ ì¤‘' : 'ëŒ€ê¸°';
  }

  function createRec() {
    rec = new SpeechRec();
    rec.lang = 'ko-KR';
    rec.continuous = true;
    rec.interimResults = true;
    rec.maxAlternatives = 1;

    rec.onstart = () => setUI(true);
    rec.onresult = (e) => {
      let interim = '';
      for (let i = e.resultIndex; i < e.results.length; i++) {
        const t = e.results[i][0].transcript;
        if (e.results[i].isFinal) {
          appendText(t, true);
        } else {
          interim += t;
        }
      }
      if (interim) appendText(interim, false);
    };
    rec.onerror = (e) => appendText(`(ì˜¤ë¥˜: ${e.error})`, true);
    rec.onend = () => {
      if (recognizing) {
        try { rec.start(); } catch(_) {}
      } else {
        setUI(false);
      }
    };
  }

  function startRec() {
    if (!rec) createRec();
    try { rec.start(); } catch(_) {}
  }

  function stopRec() {
    if (rec) rec.stop();
    setUI(false);
  }

  // ğŸ”‘ ë§ˆì´í¬ ê¶Œí•œ ì˜ˆì—´ ì¶”ê°€
  async function ensureMic() {
    if (!navigator.mediaDevices?.getUserMedia) return true;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach(t => t.stop());
      return true;
    } catch (e) {
      appendText(`(ë§ˆì´í¬ ê¶Œí•œ í•„ìš”: ${e.name || e.message})`, true);
      return false;
    }
  }

  // ë²„íŠ¼ ì´ë²¤íŠ¸
  btn.addEventListener('click', async () => {
    if (!recognizing) {
      const ok = await ensureMic();
      if (!ok) return;
      startRec();
    } else {
      recognizing = false;
      stopRec();
    }
  });

  clearBtn.addEventListener('click', () => {
    scr.textContent = '';
    interimSpan = null;
  });

  copyBtn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(scr.textContent);
      stateText.textContent = 'ë³µì‚¬ë¨';
      setTimeout(()=> stateText.textContent = recognizing ? 'ì¸ì‹ ì¤‘' : 'ëŒ€ê¸°', 1000);
    } catch { alert('ë³µì‚¬ ì‹¤íŒ¨: ë¸Œë¼ìš°ì € ê¶Œí•œ í™•ì¸'); }
  });

  saveBtn.addEventListener('click', () => {
    const blob = new Blob([scr.textContent], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    const dt = new Date().toISOString().replace(/[:.]/g,'-');
    a.download = `subtitle-${dt}.txt`;
    a.click();
    URL.revokeObjectURL(a.href);
  });

  fsSel.addEventListener('change', () => {
    scr.style.fontSize = fsSel.value+'px';
  });
  scr.style.fontSize = fsSel.value+'px';
})();
</script>
</body>
</html>
