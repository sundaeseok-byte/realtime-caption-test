<!doctype html>

<html lang="ko">

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>ì‹¤ì‹œê°„ í•œêµ­ì–´ ìë§‰ (íƒ€ìê¸° ìŠ¤íƒ€ì¼)</title>

  <style>

    :root { --fs: 22px; }

    body { margin:0; background:#111; color:#eee; font:var(--fs)/1.6 "Noto Sans KR",sans-serif; }

    header { padding:10px; border-bottom:1px solid #444; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    button { padding:6px 14px; border-radius:6px; border:none; cursor:pointer; font-weight:600; }

    button.primary { background:#4da3ff; color:#000; }

    button.danger  { background:#ff4d6d; color:#000; }

    #screen { padding:12px; height:80vh; overflow-y:auto; white-space:pre-wrap; }

    #state { margin-left:auto; color:#aaa; }

  </style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">ğŸ™ï¸ ì‹œì‘</button>

    <button id="clear">ğŸ§¹ ì§€ìš°ê¸°</button>

    <button id="copy">ğŸ“‹ ë³µì‚¬</button>

    <span id="state">ëŒ€ê¸°</span>

  </header>



  <div id="screen"></div>



<script>

(() => {

  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (!Rec) {

    document.body.innerHTML = "<p style='padding:16px'>âŒ í¬ë¡¬/ì‚¼ì„± ì¸í„°ë„· ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤í–‰í•´ì£¼ì„¸ìš”.</p>";

    return;

  }



  const r = new Rec();

  r.lang = "ko-KR";

  r.continuous = true;

  r.interimResults = true;



  const toggle = document.getElementById("toggle");

  const clearBtn= document.getElementById("clear");

  const copyBtn = document.getElementById("copy");

  const state   = document.getElementById("state");

  const screen  = document.getElementById("screen");



  let recognizing = false;



  // í™”ë©´ì— append-only í…ìŠ¤íŠ¸ ë…¸ë“œ

  const tape = document.createTextNode("");

  screen.appendChild(tape);



  // ===== íƒ€ìê¸° ë²„í¼ =====

  let buffer = "";            // ìƒˆë¡œ ë“¤ì–´ì˜¨ ê¸€ìë“¤

  let typingTimer = null;     // íƒ€ìê¸° ì¶œë ¥ íƒ€ì´ë¨¸

  const BUFFER_DELAY_MS = 600; // ì…ë ¥ ë°›ê³  ê¸°ë‹¤ë¦¬ëŠ” ì‹œê°„

  const TYPING_INTERVAL = 120; // ê¸€ìë§ˆë‹¤ ì¶œë ¥ í…€(ms)



  function startTyping(){

    if (typingTimer) return;

    typingTimer = setInterval(()=>{

      if (buffer.length>0){

        tape.data += buffer[0];

        buffer = buffer.slice(1);

        screen.scrollTop = screen.scrollHeight;

      } else {

        clearInterval(typingTimer);

        typingTimer = null;

      }

    }, TYPING_INTERVAL);

  }



  let bufferDelayTimer = null;

  function addToBuffer(text){

    if (!text) return;

    buffer += text;

    if (bufferDelayTimer) clearTimeout(bufferDelayTimer);

    bufferDelayTimer = setTimeout(()=>{

      startTyping();

    }, BUFFER_DELAY_MS);

  }



  // ===== Speech Recognition ì´ë²¤íŠ¸ =====

  r.onresult = (e) => {

    let interim = "";

    let finals  = [];



    for (let i=e.resultIndex; i<e.results.length; i++){

      const seg = e.results[i][0].transcript;

      if (e.results[i].isFinal) finals.push(seg);

      else interim += seg;

    }



    if (interim) {

      addToBuffer(interim);

    }

    if (finals.length){

      const raw = finals[finals.length-1];

      addToBuffer(" " + raw + " ");

    }

  };



  r.onstart = () => { state.textContent="ğŸ¤ ì¸ì‹ ì¤‘"; toggle.textContent="â¸ï¸ ì¤‘ì§€"; toggle.className="danger"; };

  r.onend = () => {

    if (recognizing) { try { r.start(); } catch {} }

   