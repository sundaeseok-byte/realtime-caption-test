<!doctype html>

<html lang="ko">

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>ì‹¤ì‹œê°„ í•œêµ­ì–´ ìë§‰ (ë°˜ë³µ ì–µì œ ê°•í™”)</title>

  <style>

    body { margin:0; background:#111; color:#eee; font:18px/1.6 "Noto Sans KR",sans-serif; }

    header { padding:10px; border-bottom:1px solid #444; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    button { padding:6px 12px; border-radius:6px; border:none; cursor:pointer; }

    button.primary { background:#4da3ff; color:#000; }

    button.danger { background:#ff4d6d; color:#000; }

    #screen { padding:12px; height:75vh; overflow-y:auto; white-space:pre-wrap; }

    #state { margin-left:auto; color:#aaa; }

  </style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">ğŸ™ï¸ ì‹œì‘</button>

    <button id="clear">ğŸ§¹ ì§€ìš°ê¸°</button>

    <button id="copy">ğŸ“‹ ë³µì‚¬</button>

    <span id="state">ëŒ€ê¸°</span>

  </header>

  <div id="screen"></div>



<script>

(() => {

  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (!Rec) {

    document.body.innerHTML = "<p style='padding:16px'>âŒ í¬ë¡¬/ì‚¼ì„± ì¸í„°ë„· ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.</p>";

    return;

  }



  const r = new Rec();

  r.lang = "ko-KR";

  r.continuous = true;

  r.interimResults = true;



  let recognizing = false;

  const toggle = document.getElementById("toggle");

  const clearBtn = document.getElementById("clear");

  const copyBtn = document.getElementById("copy");

  const state = document.getElementById("state");

  const screen = document.getElementById("screen");



  // ëˆ„ì /í‘œì‹œ ìƒíƒœ

  let finalText = "";         // í™•ì • ëˆ„ì  (ì¤„ë°”ê¿ˆ ì—†ìŒ, ëì— ê³µë°± 1ê°œ ìœ ì§€)

  let lastShown = "";         // ë§ˆì§€ë§‰ìœ¼ë¡œ í™”ë©´ì— í‘œì‹œí•œ ì „ì²´ ë¬¸ìì—´

  let recentFinals = [];      // ìµœê·¼ final ì •ê·œí™” ë²„ì „ (ì¤‘ë³µ ì°¨ë‹¨ìš©)

  const MAX_RECENT = 20;



  // íƒ€ì„ìœˆë„ìš° ì¤‘ë³µ ì°¨ë‹¨

  let lastFinalNorm = "";

  let lastFinalAt = 0;

  const FINAL_DEDUP_MS = 400; // 0.4ì´ˆ ë‚´ ë™ì¼ final ë¬´ì‹œ



  // ì •ê·œí™”: ê³µë°±/ë¬¸ì¥ë¶€í˜¸/ì¼€ì´ìŠ¤ ì°¨ì´ ì œê±°

  function norm(s){

    return (s || "")

      .replace(/\s+/g, " ")

      .replace(/[.,!?â€¦ï¼ï¼Ÿã€‚~]+$/g, "") // ë ë¬¸ì¥ë¶€í˜¸ ì œê±°

      .trim()

      .toLowerCase();

  }



  function remember(normLine){

    if (!normLine) return false;

    if (recentFinals.includes(normLine)) return false;

    recentFinals.push(normLine);

    if (recentFinals.length > MAX_RECENT) recentFinals.shift();

    return true;

  }



  // finalTextì˜ ëë¶€ë¶„ê³¼ newSegì˜ ì•ë¶€ë¶„ì´ ê²¹ì¹˜ë©´ "ê²¹ì¹˜ì§€ ì•ŠëŠ” ê¼¬ë¦¬"ë§Œ ë°˜í™˜

  function deltaAppend(prev, newSeg){

    if (!newSeg) return "";

    // ë¹„êµ ê¸¸ì´ë¥¼ ì œí•œ (ë§ˆì§€ë§‰ 100ìì™€ newSegì˜ ì• 100ìê¹Œì§€ë§Œ ë¹„êµ)

    const max = 100;

    const tail = prev.slice(-max);

    const head = newSeg.slice(0, max);

    let k = Math.min(tail.length, head.length);

    // ê°€ì¥ ê¸´ ê²¹ì¹¨ ì°¾ê¸°

    while (k > 0) {

      if (tail.endsWith(head.slice(0, k))) break;

      k--;

    }

    return newSeg.slice(k);

  }



  function setScreen(text){

    if (text === lastShown) return; // ë¶ˆí•„ìš”í•œ ë¦¬ë Œë” ë°©ì§€

    screen.textContent = text;

    lastShown = text;

    screen.scrollTop = screen.scrollHeight;

  }



  r.onresult = (e) => {

    let interim = "";

    for (let i=e.resultIndex; i<e.results.length; i++) {

      const raw = e.results[i][0].transcript;

      if (e.results[i].isFinal) {

        const now = performance.now();

        const n = norm(raw);

        // íƒ€ì„ìœˆë„ìš° + ìµœê·¼ëª©ë¡ ì¤‘ë³µ ì°¨ë‹¨

        if (n && (n === lastFinalNorm && (now - lastFinalAt) < FINAL_DEDUP_MS)) {

          continue;

        }

        lastFinalNorm = n;

        lastFinalAt = now;

        if (!remember(n)) continue;



        // ê²¹ì¹¨ ì œê±° deltaë§Œ ë¶™ì´ê¸°

        const delta = deltaAppend(finalText, raw.trim());

        if (delta) {

          // ëì— ê³µë°± í•˜ë‚˜ ìœ ì§€

          finalText = (finalText + delta).replace(/\s*$/,"") + " ";

        }

      } else {

        interim += raw;

      }

    }

    setScreen(finalText + interim);

  };



  r.onstart = () => { state.textContent="ğŸ¤ ì¸ì‹ ì¤‘"; toggle.textContent="â¸ï¸ ì¤‘ì§€"; toggle.className="danger"; };

  r.onend = () => {

    if (recognizing) { try{ r.start(); }catch{} }

    else { state.textContent="ëŒ€ê¸°"; toggle.textContent="ğŸ™ï¸ ì‹œì‘"; toggle.className="primary"; }

  };



  toggle.onclick = async () => {

    if (!recognizing) {

      try { 

        const s = await navigator.mediaDevices.getUserMedia({audio:true}); 

        s.getTracks().forEach(t=>t.stop()); 

      } catch(e){ 

        alert("ë§ˆì´í¬ ê¶Œí•œ í•„ìš”"); 

        return; 

      }

      recognizing = true; r.start();

    } else { recognizing = false; r.stop(); }

  };



  clearBtn.onclick = () => { 

    finalText=""; lastShown=""; recentFinals=[]; lastFinalNorm=""; lastFinalAt=0;

    setScreen("");

  };

  copyBtn.onclick = async () => {

    try { 

      await navigator.clipboard.writeText(screen.textContent); 

      state.textContent="ë³µì‚¬ë¨"; 

      setTimeout(()=> state.textContent=recognizing?"ğŸ¤ ì¸ì‹ ì¤‘":"ëŒ€ê¸°",800); 

    }

    catch { alert("ë³µì‚¬ ì‹¤íŒ¨"); }

  };

})();

</script>

</body>

</html>