<!doctype html>

<html lang="ko">

<head>

<meta charset="utf-8" />

<meta name="viewport" content="width=device-width,initial-scale=1" />

<title>실시간 자막 — 타자형 vs 완성형</title>

<style>

  :root { --fs: 22px; }

  *{box-sizing:border-box}

  body{margin:0;background:#0b0f14;color:#e9eef5;font:var(--fs)/1.6 "Noto Sans KR",system-ui,sans-serif}

  header{padding:10px;border-bottom:1px solid #1e2a36;display:flex;gap:8px;align-items:center;flex-wrap:wrap}

  button{padding:6px 12px;border-radius:8px;border:1px solid #1e2a36;background:#111923;color:#e9eef5;cursor:pointer;font-weight:600}

  button.primary{background:#4da3ff;color:#001733;border-color:transparent}

  button.danger{background:#ff4d6d;color:#250008;border-color:transparent}

  .group{display:flex;gap:6px;align-items:center}

  .pill{font-size:12px;color:#9aa3ad}

  main{display:grid;grid-template-columns:1fr 1fr;gap:10px;padding:10px}

  .col{border:1px solid #1e2a36;border-radius:14px;background:#0e141b;display:flex;flex-direction:column;min-height:70vh}

  .col header{padding:8px 12px;border-bottom:1px solid #1e2a36;display:flex;justify-content:space-between;align-items:center}

  .title{font-weight:700;color:#9bb2c7}

  .pane{padding:12px;white-space:pre-wrap;overflow:auto;flex:1}

  .note{font-size:12px;color:#8aa0b4;padding:8px 12px;border-top:1px solid #1e2a36}

  #state{margin-left:auto;color:#9aa3ad}

  .switch{display:flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid #1e2a36;border-radius:8px;background:#111923}

  @media (max-width: 800px){ main{grid-template-columns:1fr} }

</style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">🎙️ 시작</button>

    <button id="clear">🧹 지우기</button>

    <button id="copy">📋 두 패널 복사</button>



    <div class="group">

      <button id="smaller" title="글자 작게">A−</button>

      <button id="bigger"  title="글자 크게">A+</button>

      <span id="fsLabel" class="pill"></span>

    </div>



    <label class="switch" title="완성형에만 적용됩니다 (무료 공개 API, 느릴 수 있음)">

      <input type="checkbox" id="spellToggle" />

      맞춤법 보정(완성형)

    </label>



    <span id="state">대기</span>

  </header>



  <main>

    <section class="col" id="col-live">

      <header><span class="title">✍️ 실시간 타자형 (append-only)</span></header>

      <div id="livePane" class="pane" aria-live="polite"></div>

      <div class="note">바로바로 붙는 출력. 이미 찍힌 글자는 절대 수정하지 않습니다.</div>

    </section>



    <section class="col" id="col-final">

      <header><span class="title">✅ 완성형 (중복 억제 + 디바운스)</span></header>

      <div id="finalPane" class="pane"></div>

      <div class="note">잠깐 생각한 뒤(약 0.9초) 한 문장씩 확정해 줄바꿈으로 저장합니다.</div>

    </section>

  </main>



<script>

(() => {

  /* ============ 글자 크기 ============ */

  const FONT_MIN=16, FONT_MAX=64, STEP=2;

  const fsLabel = document.getElementById("fsLabel");

  let curFs = Number(localStorage.getItem("subtitle_fs_px") || 22);

  function applyFs(px){

    curFs = Math.min(FONT_MAX, Math.max(FONT_MIN, px));

    document.documentElement.style.setProperty("--fs", curFs + "px");

    fsLabel.textContent = `${curFs}px`;

    localStorage.setItem("subtitle_fs_px", String(curFs));

  }

  applyFs(curFs);

  document.getElementById("smaller").onclick = () => applyFs(curFs - STEP);

  document.getElementById("bigger").onclick  = () => applyFs(curFs + STEP);



  /* ============ 음성 인식 ============ */

  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (!Rec){

    document.body.innerHTML = "<p style='padding:16px'>❌ 이 브라우저는 Web Speech API를 지원하지 않습니다. Chrome/삼성 인터넷을 사용하세요.</p>";

    return;

  }

  const r = new Rec();

  r.lang = "ko-KR";

  r.continuous = true;

  r.interimResults = true;

  r.maxAlternatives = 1;



  const toggle = document.getElementById("toggle");

  const clearBtn= document.getElementById("clear");

  const copyBtn = document.getElementById("copy");

  const state   = document.getElementById("state");

  const livePane= document.getElementById("livePane");

  const finalPane= document.getElementById("finalPane");

  const spellToggle = document.getElementById("spellToggle");



  let recognizing = false;



  /* ============ 좌측: 실시간 타자형 (append-only) ============ */

  const liveNode = document.createTextNode("");

  livePane.appendChild(liveNode);



  let liveCurrentStream = ""; // 엔진이 보는 최신 임시 문자열

  let liveQueuedDelta   = ""; // 아직 출력 안 한 꼬리

  let liveFlushTimer = null;

  let liveLastFlushAt = 0;

  const LIVE_THROTTLE_MS = 220; // ⏳ 타자 속도 (원하면 280~400으로 더 느리게)



  function commonPrefixLen(a,b){

    const n = Math.min(a.length, b.length);

    let i=0; while (i<n && a.charCodeAt(i)===b.charCodeAt(i)) i++; return i;

  }

  function liveScheduleAppend(newStream){

    const cpl = commonPrefixLen(liveCurrentStream, newStream);

    const delta = newStream.slice(cpl);

    if (!delta) return;

    liveQueuedDelta += delta;



    const now = performance.now();

    const due = Math.max(0, LIVE_THROTTLE_MS - (now - liveLastFlushAt));

    if (!liveFlushTimer) liveFlushTimer = setTimeout(liveFlush, due);

    liveCurrentStream = newStream; // 화면은 append-only, 내부 스냅샷만 교체

  }

  function liveFlush(){

    if (liveQueuedDelta){

      liveNode.data += liveQueuedDelta; // 교체 없이 덧붙임

      livePane.scrollTop = livePane.scrollHeight;

      liveQueuedDelta = "";

    }

    liveLastFlushAt = performance.now();

    liveFlushTimer = null;

  }



  /* ============ 우측: 완성형 (중복 억제 + 디바운스 + 선택적 맞춤법) ============ */

  const finalNode = document.createTextNode("");

  finalPane.appendChild(finalNode);



  // final 디바운스 & 중복 억제

  let pendingFinal = "";           // 최근 수집된 final 후보

  let debounceTimer = null;

  const DEBOUNCE_MS = 900;         // 잠깐 기다렸다가 한 번만 확정

  let lastFinalNorm = "";          // 짧은 시간 내 동일 문장 무시

  let lastFinalAt   = 0;

  const FINAL_DEDUP_MS = 1000;



  function norm(s){ return (s||"").replace(/\s+/g," ").replace(/[.,!?…！？。~]+$/g,"").trim().toLowerCase(); }



  // 완성형에 줄바꿈으로 추가

  function appendFinalLine(line){

    if (!line) return;

    finalNode.data += (finalNode.data && !/\n$/.test(finalNode.data) ? "\n" : "") + line;

    finalPane.scrollTop = finalPane.scrollHeight;

  }



  // 공개 LanguageTool로 간단 보정 (실패하면 원문 사용)

  async function grammarCheckKo(text, timeoutMs = 1500){

    if (!spellToggle.checked) return text;

    const controller = new AbortController();

    const to = setTimeout(()=>controller.abort(), timeoutMs);

    try{

      const res = await fetch("https://api.languagetool.org/v2/check", {

        method: "POST",

        headers: {"Content-Type":"application/x-www-form-urlencoded"},

        body: new URLSearchParams({ language:"ko", text }),

        signal: controller.signal

      });

      clearTimeout(to);

      if (!res.ok) throw new Error("HTTP "+res.status);

      const data = await res.json();

      let out = text;

      const matches = (data.matches || []).sort((a,b)=> (b.offset - a.offset));

      for (const m of matches){

        const rep = (m.replacements && m.replacements[0]?.value) || null;

        if (!rep) continue;

        const start = m.offset, end = m.offset + m.length;

        out = out.slice(0,start) + rep + out.slice(end);

      }

      return out;

    }catch{

      clearTimeout(to);

      return text;

    }

  }



  function commitFinalNow(txt){

    const src = txt.trim();

    if (!src) return;

    grammarCheckKo(src).then(fixed => {

      appendFinalLine(fixed);

      pendingFinal = "";

    });

  }



  /* ============ 인식 이벤트 ============ */

  r.onresult = (e) => {

    let interim = "";

    let finals  = [];



    for (let i=e.resultIndex; i<e.results.length; i++){

      const seg = e.results[i][0].transcript;

      if (e.results[i].isFinal) {

        const now = performance.now();

        const n = norm(seg);

        if (n && n===lastFinalNorm && (now-lastFinalAt)<FINAL_DEDUP_MS) continue; // 빠른 중복 차단

        lastFinalNorm = n; lastFinalAt = now;

        finals.push(seg);

      } else {

        interim += seg;

      }

    }



    // 좌측 실시간: interim을 델타로 즉시(타자속도로) 붙임

    if (interim) liveScheduleAppend(interim);



    // 우측 완성형: final을 디바운스 후 한 번만 확정

    if (finals.length){

      pendingFinal = finals[finals.length-1];

      if (debounceTimer) clearTimeout(debounceTimer);

      debounceTimer = setTimeout(()=> commitFinalNow(pendingFinal), DEBOUNCE_MS);

      // 좌측 실시간 스트림은 다음 문장 대비 초기화(화면은 유지, 내부 스냅샷만 리셋)

      liveCurrentStream = "";

    }

  };



  r.onstart = () => { state.textContent="🎤 인식 중"; toggle.textContent="⏸️ 중지"; toggle.className="danger"; };

  r.onend = () => {

    if (recognizing) { try{ r.start(); }catch{} }

    else { state.textContent="대기"; toggle.textContent="🎙️ 시작"; toggle.className="primary"; }

  };

  r.onerror = (e) => {

    // 오류는 두 패널 중 우측에만 남김

    appendFinalLine(`(오류: ${e.error})`);

  };



  toggle.onclick = async () => {

    if (!recognizing){

      try{

        const s = await navigator.mediaDevices.getUserMedia({audio:true});

        s.getTracks().forEach(t=>t.stop());

      }catch{

        alert("마이크 권한이 필요합니다.");

        return;

      }

      recognizing = true; r.start();

    }else{

      recognizing = false; r.stop();

    }

  };



  clearBtn.onclick = () => {

    liveNode.data = "";

    finalNode.data = "";

    liveCurrentStream = "";

    liveQueuedDelta = "";

    if (liveFlushTimer){ clearTimeout(liveFlushTimer); liveFlushTimer=null; }

    pendingFinal = "";

    if (debounceTimer){ clearTimeout(debounceTimer); debounceTimer=null; }

  };



  copyBtn.onclick = async () => {

    const both = `[실시간]\n${liveNode.data}\n\n[완성형]\n${finalNode.data}`;

    try{

      await navigator.clipboard.writeText(both);

      state.textContent = "복사됨";

      setTimeout(()=> state.textContent = recognizing ? "🎤 인식 중" : "대기", 900);

    }catch{ alert("복사 실패"); }

  };

})();

</script>

</body>

</html>