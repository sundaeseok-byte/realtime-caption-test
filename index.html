<!doctype html>

<html lang="ko">

<head>

<meta charset="utf-8" />

<meta name="viewport" content="width=device-width,initial-scale=1" />

<title>ì‹¤ì‹œê°„ ìë§‰ â€” íƒ€ìí˜• vs ì™„ì„±í˜•</title>

<style>

  :root { --fs: 22px; }

  *{box-sizing:border-box}

  body{

    margin:0; background:#0b0f14; color:#e9eef5;

    font:var(--fs)/1.6 "Noto Sans KR",system-ui,sans-serif

  }

  header{

    padding:10px; border-bottom:1px solid #1e2a36;

    display:flex; gap:6px; align-items:center; flex-wrap:wrap

  }

  button{

    padding:6px 12px; border-radius:8px;

    border:1px solid #1e2a36; background:#111923;

    color:#e9eef5; cursor:pointer; font-weight:600

  }

  button.primary{background:#4da3ff;color:#001733;border-color:transparent}

  button.danger{background:#ff4d6d;color:#250008;border-color:transparent}

  .group{display:flex;gap:6px;align-items:center}

  .pill{font-size:12px;color:#9aa3ad}

  main{

    display:grid; grid-template-columns:1fr 1fr;

    gap:6px; padding:6px

  }

  .col{

    border:1px solid #1e2a36; border-radius:12px;

    background:#0e141b; display:flex; flex-direction:column;

    min-height:60vh

  }

  .col header{padding:6px 10px;border-bottom:1px solid #1e2a36}

  .title{font-weight:700;color:#9bb2c7;font-size:14px}

  .pane{padding:10px;white-space:pre-wrap;overflow:auto;flex:1}

  .note{font-size:11px;color:#8aa0b4;padding:6px 10px;border-top:1px solid #1e2a36}

  #state{margin-left:auto;color:#9aa3ad}

  .switch{display:flex;align-items:center;gap:6px;padding:6px 10px;

    border:1px solid #1e2a36;border-radius:8px;background:#111923}



  /* ğŸ“± ëª¨ë°”ì¼ ìµœì í™” */

  @media (max-width: 768px){

    main{grid-template-columns:1fr; gap:4px; padding:4px}

    .col{min-height:40vh}

    body{font-size:calc(var(--fs) + 2px);}

    .title{font-size:13px}

    .note{font-size:10px}

  }

</style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">ğŸ™ï¸ ì‹œì‘</button>

    <button id="clear">ğŸ§¹ ì§€ìš°ê¸°</button>

    <button id="copy">ğŸ“‹ ë‘ íŒ¨ë„ ë³µì‚¬</button>



    <div class="group">

      <button id="smaller" title="ê¸€ì ì‘ê²Œ">Aâˆ’</button>

      <button id="bigger"  title="ê¸€ì í¬ê²Œ">A+</button>

      <span id="fsLabel" class="pill"></span>

    </div>



    <label class="switch" title="ì™„ì„±í˜•ì—ë§Œ ì ìš©ë©ë‹ˆë‹¤ (ë¬´ë£Œ ê³µê°œ API, ëŠë¦´ ìˆ˜ ìˆìŒ)">

      <input type="checkbox" id="spellToggle" />

      ë§ì¶¤ë²• ë³´ì •(ì™„ì„±í˜•)

    </label>



    <span id="state">ëŒ€ê¸°</span>

  </header>



  <main>

    <section class="col" id="col-live">

      <header><span class="title">âœï¸ ì‹¤ì‹œê°„ íƒ€ìí˜• (append-only)</span></header>

      <div id="livePane" class="pane" aria-live="polite"></div>

      <div class="note">ë°”ë¡œë°”ë¡œ ë¶™ëŠ” ì¶œë ¥. ì´ë¯¸ ì°íŒ ê¸€ìëŠ” ì ˆëŒ€ ìˆ˜ì •í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>

    </section>



    <section class="col" id="col-final">

      <header><span class="title">âœ… ì™„ì„±í˜• (ì¤‘ë³µ ì–µì œ + ë””ë°”ìš´ìŠ¤)</span></header>

      <div id="finalPane" class="pane"></div>

      <div class="note">ì ê¹ ìƒê°í•œ ë’¤(ì•½ 0.9ì´ˆ) í•œ ë¬¸ì¥ì”© í™•ì •í•´ ì¤„ë°”ê¿ˆìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.</div>

    </section>

  </main>



<script>

(() => {

  /* ============ ê¸€ì í¬ê¸° ============ */

  const FONT_MIN=16, FONT_MAX=64, STEP=2;

  const fsLabel = document.getElementById("fsLabel");

  let curFs = Number(localStorage.getItem("subtitle_fs_px") || 22);

  function applyFs(px){

    curFs = Math.min(FONT_MAX, Math.max(FONT_MIN, px));

    document.documentElement.style.setProperty("--fs", curFs + "px");

    fsLabel.textContent = `${curFs}px`;

    localStorage.setItem("subtitle_fs_px", String(curFs));

  }

  applyFs(curFs);

  document.getElementById("smaller").onclick = () => applyFs(curFs - STEP);

  document.getElementById("bigger").onclick  = () => applyFs(curFs + STEP);



  /* ============ ìŒì„± ì¸ì‹ ============ */

  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (!Rec){

    document.body.innerHTML = "<p style='padding:16px'>âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” Web Speech APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome/ì‚¼ì„± ì¸í„°ë„·ì„ ì‚¬ìš©í•˜ì„¸ìš”.</p>";

    return;

  }

  const r = new Rec();

  r.lang = "ko-KR";

  r.continuous = true;

  r.interimResults = true;

  r.maxAlternatives = 1;



  const toggle = document.getElementById("toggle");

  const clearBtn= document.getElementById("clear");

  const copyBtn = document.getElementById("copy");

  const state   = document.getElementById("state");

  const livePane= document.getElementById("livePane");

  const finalPane= document.getElementById("finalPane");

  const spellToggle = document.getElementById("spellToggle");



  let recognizing = false;



  /* ============ ì¢Œì¸¡: ì‹¤ì‹œê°„ íƒ€ìí˜• (append-only) ============ */

  const liveNode = document.createTextNode("");

  livePane.appendChild(liveNode);



  let liveCurrentStream = "";

  let liveQueuedDelta   = "";

  let liveFlushTimer = null;

  let liveLastFlushAt = 0;

  const LIVE_THROTTLE_MS = 220;



  function commonPrefixLen(a,b){

    const n = Math.min(a.length, b.length);

    let i=0; while (i<n && a.charCodeAt(i)===b.charCodeAt(i)) i++; return i;

  }

  function liveScheduleAppend(newStream){

    const cpl = commonPrefixLen(liveCurrentStream, newStream);

    const delta = newStream.slice(cpl);

    if (!delta) return;

    liveQueuedDelta += delta;



    const now = performance.now();

    const due = Math.max(0, LIVE_THROTTLE_MS - (now - liveLastFlushAt));

    if (!liveFlushTimer) liveFlushTimer = setTimeout(liveFlush, due);

    liveCurrentStream = newStream;

  }

  function liveFlush(){

    if (liveQueuedDelta){

      liveNode.data += liveQueuedDelta;

      livePane.scrollTop = livePane.scrollHeight;

      liveQueuedDelta = "";

    }

    liveLastFlushAt = performance.now();

    liveFlushTimer = null;

  }



  /* ============ ìš°ì¸¡: ì™„ì„±í˜• (ì¤‘ë³µ ì–µì œ + ë””ë°”ìš´ìŠ¤ + ë§ì¶¤ë²• ì˜µì…˜) ============ */

  const finalNode = document.createTextNode("");

  finalPane.appendChild(finalNode);



  let pendingFinal = "";

  let debounceTimer = null;

  const DEBOUNCE_MS = 900;

  let lastFinalNorm = "";

  let lastFinalAt   = 0;

  const FINAL_DEDUP_MS = 1000;



  function norm(s){ return (s||"").replace(/\s+/g," ").replace(/[.,!?â€¦ï¼ï¼Ÿã€‚~]+$/g,"").trim().toLowerCase(); }



  function appendFinalLine(line){

    if (!line) return;

    finalNode.data += (finalNode.data && !/\n$/.test(finalNode.data) ? "\n" : "") + line;

    finalPane.scrollTop = finalPane.scrollHeight;

  }



  async function grammarCheckKo(text, timeoutMs = 1500){

    if (!spellToggle.checked) return text;

    const controller = new AbortController();

    const to = setTimeout(()=>controller.abort(), timeoutMs);

    try{

      const res = await fetch("https://api.languagetool.org/v2/check", {

        method:"POST",

        headers:{"Content-Type":"application/x-www-form-urlencoded"},

        body:new URLSearchParams({ language:"ko", text }),

        signal:controller.signal

      });

      clearTimeout(to);

      if (!res.ok) throw new Error("HTTP "+res.status);

      const data = await res.json();

      let out = text;

      const matches = (data.matches||[]).sort((a,b)=>b.offset-a.offset);

      for (const m of matches){

        const rep = (m.replacements && m.replacements[0]?.value) || null;

        if (!rep) continue;

        out = out.slice(0,m.offset)+rep+out.slice(m.offset+m.length);

      }

      return out;

    }catch{clearTimeout(to);return text;}

  }



  function commitFinalNow(txt){

    const src = txt.trim();

    if (!src) return;

    grammarCheckKo(src).then(fixed=>{

      appendFinalLine(fixed);

      pendingFinal="";

    });

  }



  r.onresult = (e) => {

    let interim="", finals=[];

    for (let i=e.resultIndex; i<e.results.length; i++){

      const seg = e.results[i][0].transcript;

      if (e.results[i].isFinal){

        const now = performance.now();

        const n = norm(seg);

        if (n && n===lastFinalNorm && (now-lastFinalAt)<FINAL_DEDUP_MS) continue;

        lastFinalNorm=n; lastFinalAt=now;

        finals.push(seg);

      } else interim+=seg;

    }

    if (interim) liveScheduleAppend(interim);

    if (finals.length){

      pendingFinal=finals[finals.length-1];

      if (debounceTimer) clearTimeout(debounceTimer);

      debounceTimer=setTimeout(()=>commitFinalNow(pendingFinal),DEBOUNCE_MS);

      liveCurrentStream="";

    }

  };



  r.onstart=()=>{state.textContent="ğŸ¤ ì¸ì‹ ì¤‘";toggle.textContent="â¸ï¸ ì¤‘ì§€";toggle.className="danger";};

  r.onend=()=>{if(recognizing){try{r.start();}catch{}}else{state.textContent="ëŒ€ê¸°";toggle.textContent="ğŸ™ï¸ ì‹œì‘";toggle.className="primary";}};

  r.onerror=e=>appendFinalLine(`(ì˜¤ë¥˜:${e.error})`);



  toggle.onclick=async()=>{

    if(!recognizing){

      try{const s=await navigator.mediaDevices.getUserMedia({audio:true});s.getTracks().forEach(t=>t.stop());}

      catch{alert("ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.");return;}

      recognizing=true;r.start();

    }else{recognizing=false;r.stop();}

  };

  clearBtn.onclick=()=>{

    liveNode.data="";finalNode.data="";liveCurrentStream="";liveQueuedDelta="";

    if(liveFlushTimer){clearTimeout(liveFlushTimer);liveFlushTimer=null;}

    pendingFinal="";if(debounceTimer){clearTimeout(debounceTimer);debounceTimer=null;}

  };

  copyBtn.onclick=async()=>{

    const both=`[ì‹¤ì‹œê°„]\n${liveNode.data}\n\n[ì™„ì„±í˜•]\n${finalNode.data}`;

    try{await navigator.clipboard.writeText(both);state.textContent="ë³µì‚¬ë¨";setTimeout(()=>state.textContent=recognizing?"ğŸ¤ ì¸ì‹ ì¤‘":"ëŒ€ê¸°",900);}

    catch{alert("ë³µì‚¬ ì‹¤íŒ¨");}

  };

})();

</script>

</body>

</html>