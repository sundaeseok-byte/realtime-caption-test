<!doctype html>

<html lang="ko">

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>ì‹¤ì‹œê°„ í•œêµ­ì–´ ìë§‰ (ì¤„ë°”ê¿ˆ ì—†ì´ ì´ì–´ì“°ê¸°)</title>

  <style>

    :root { --bg:#0b0f14; --fg:#e9eef5; --muted:#8aa0b4; --accent:#4da3ff; --border:#1f2a36; }

    * { box-sizing:border-box; }

    body { margin:0; background:var(--bg); color:var(--fg); font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Arial,sans-serif; }

    header { padding:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; border-bottom:1px solid var(--border); }

    button { padding:8px 12px; border-radius:10px; border:1px solid var(--border); cursor:pointer; font-weight:600; }

    button.primary { background:var(--accent); color:#001733; border-color:transparent; }

    button.danger { background:#ff4d6d; color:#250008; border-color:transparent; }

    label, select { border:1px solid var(--border); padding:8px 12px; border-radius:10px; background:#111923; color:var(--fg); font-weight:600; }

    main { padding:12px; }

    #hist { border:1px solid var(--border); border-radius:16px; background:#0e141b; padding:14px; height:68vh; overflow:auto; white-space:pre-wrap; }

    .status { margin-left:auto; display:flex; align-items:center; gap:8px; color:var(--muted); }

    #lamp { width:10px; height:10px; border-radius:50%; background:#485a6c; display:inline-block; }

    #lamp.on { background:#27d07d; box-shadow:0 0 0 3px rgba(39,208,125,0.15); }

  </style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">ğŸ™ï¸ ì‹œì‘</button>

    <button id="clear">ğŸ§¹ ì§€ìš°ê¸°</button>

    <button id="copy">ğŸ“‹ ë³µì‚¬</button>

    <button id="save">ğŸ’¾ ì €ì¥</button>

    <label title="ë¬¸ì¥ í™•ì • ì—†ì´ ë“¤ë¦¬ëŠ” ëŒ€ë¡œ ì¦‰ì‹œ ëˆ„ì "><input type="checkbox" id="rawMode" checked /> RAW(ì¦‰ì‹œ ëˆ„ì )</label>

    <label title="íƒ€ì„ìŠ¤íƒ¬í”„"><input type="checkbox" id="timestamp" /> íƒ€ì„ìŠ¤íƒ¬í”„</label>

    <select id="fontsize" title="ê¸€ì í¬ê¸°">

      <option value="18">ê¸€ì 18</option>

      <option value="22" selected>ê¸€ì 22</option>

      <option value="28">ê¸€ì 28</option>

      <option value="36">ê¸€ì 36</option>

      <option value="48">ê¸€ì 48</option>

    </select>

    <div class="status"><span id="lamp"></span><span id="state">ëŒ€ê¸°</span></div>

  </header>



  <main>

    <div id="hist" aria-live="polite" aria-atomic="false"></div>

  </main>



<script>

(() => {

  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (!Rec) {

    document.body.innerHTML = "<p style='padding:16px'>âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í¬ë¡¬/ì‚¼ì„± ì¸í„°ë„·ì„ ì‚¬ìš©í•˜ì„¸ìš”.</p>";

    return;

  }



  const hist = document.getElementById('hist');

  const toggle = document.getElementById('toggle');

  const clearBtn = document.getElementById('clear');

  const copyBtn = document.getElementById('copy');

  const saveBtn = document.getElementById('save');

  const rawModeChk = document.getElementById('rawMode');

  const tsChk = document.getElementById('timestamp');

  const fsSel = document.getElementById('fontsize');

  const state = document.getElementById('state');

  const lamp = document.getElementById('lamp');



  let recognizing = false;

  let rec = null;



  // RAW ëª¨ë“œ: ë„ˆë¬´ ì¦ì€ ë§ë¶™ì„ ì œì–´

  const RAW_APPEND_INTERVAL = 100; // ms

  let lastAppendAt = 0;



  // ìŠ¤ë§ˆíŠ¸ ëª¨ë“œ: ì¹¨ë¬µ í™•ì • (ì¤„ë°”ê¿ˆ ì—†ì´ ì´ì–´ì“°ê¸°)

  const SILENCE_MS = 700;

  let sentenceBuf = "";

  let silenceTimer = null;



  // í™”ë©´ êº¼ì§ ë°©ì§€(ì§€ì› ë¸Œë¼ìš°ì €ì—ì„œë§Œ)

  let wakeLock = null;

  async function keepAwake(on){

    try{

      if (on && 'wakeLock' in navigator) {

        wakeLock = await navigator.wakeLock.request('screen');

      } else if (wakeLock) {

        await wakeLock.release(); wakeLock = null;

      }

    }catch{}

  }



  function nowTS() {

    const d = new Date();

    const h = String(d.getHours()).padStart(2,'0');

    const m = String(d.getMinutes()).padStart(2,'0');

    const s = String(d.getSeconds()).padStart(2,'0');

    return `[${h}:${m}:${s}] `;

  }



  // ğŸ”¸ ì¤„ë°”ê¿ˆ ì—†ì´ ì´ì–´ì“°ê¸°: í•­ìƒ ëì— ê³µë°± í•˜ë‚˜ë§Œ ì¶”ê°€

  function appendChunk(text) {

    if (!text) return;

    const ts = tsChk.checked ? nowTS() : '';

    // ë§ˆì§€ë§‰ì´ ê³µë°±ì´ ì•„ë‹ˆë©´ ê³µë°± ì¶”ê°€

    const needSpace = hist.textContent && !/\s$/.test(hist.textContent);

    hist.append(document.createTextNode((ts ? ts : '') + (needSpace ? '' : '') + text + ' '));

    hist.scrollTop = hist.scrollHeight;

  }



  function setUI(on) {

    recognizing = on;

    toggle.textContent = on ? 'â¸ï¸ ì¤‘ì§€' : 'ğŸ™ï¸ ì‹œì‘';

    toggle.className = on ? 'danger' : 'primary';

    state.textContent = on ? 'ì¸ì‹ ì¤‘' : 'ëŒ€ê¸°';

    lamp.classList.toggle('on', on);

  }



  function createRec() {

    rec = new Rec();

    rec.lang = 'ko-KR';

    rec.continuous = true;

    rec.interimResults = true;

    rec.maxAlternatives = 1;



    let restarting = false;



    rec.onstart = () => setUI(true);



    rec.onresult = (e) => {

      let interimAccum = '';

      for (let i = e.resultIndex; i < e.results.length; i++) {

        const t = e.results[i][0].transcript;

        if (e.results[i].isFinal) {

          if (rawModeChk.checked) {

            appendChunk(t.trim()); // ìµœì¢…ë„ ì¤„ë°”ê¿ˆ ì—†ì´

          } else {

            if (t.trim()) {

              if (sentenceBuf && !/[ \u00A0]$/.test(sentenceBuf)) sentenceBuf += ' ';

              sentenceBuf += t.trim();

            }

            finalizeIfSilent(); // ì¤„ë°”ê¿ˆ ì—†ì´ ì´ì–´ì“°ê¸° í™•ì •

          }

        } else {

          interimAccum += t;

        }

      }



      if (interimAccum) {

        if (rawModeChk.checked) {

          const now = performance.now();

          if (now - lastAppendAt >= RAW_APPEND_INTERVAL) {

            appendChunk(interimAccum.trim());

            lastAppendAt = now;

          }

        } else {

          if (sentenceBuf && !/[ \u00A0]$/.test(sentenceBuf)) sentenceBuf += ' ';

          sentenceBuf += interimAccum.trim();

          finalizeIfSilent();

        }

      }

    };



    rec.onerror = (e) => {

      appendChunk(`(ì˜¤ë¥˜: ${e.error})`);

    };



    rec.onend = () => {

      if (!recognizing) return setUI(false);

      if (restarting) return;

      restarting = true;

      setTimeout(() => {

        try { rec.start(); } catch {}

        restarting = false;

      }, 250);

    };

  }



  function finalizeIfSilent(){

    if (silenceTimer) clearTimeout(silenceTimer);

    silenceTimer = setTimeout(() => {

      if (sentenceBuf.trim().length) {

        appendChunk(sentenceBuf.trim()); // ğŸ”¸ ì¤„ë°”ê¿ˆ ì—†ì´ ì´ì–´ì“°ê¸°

        sentenceBuf = '';

      }

    }, SILENCE_MS);

  }



  async function ensureMic() {

    if (!navigator.mediaDevices?.getUserMedia) return true;

    try {

      const s = await navigator.mediaDevices.getUserMedia({ audio:true });

      s.getTracks().forEach(t=>t.stop());

      return true;

    } catch(e) {

      appendChunk('(ë§ˆì´í¬ ê¶Œí•œ í•„ìš”)');

      return false;

    }

  }



  function startRec() { if (!rec) createRec(); try { rec.start(); } catch {} }

  function stopRec() { if (rec) rec.stop(); setUI(false); }



  // ì´ë²¤íŠ¸

  toggle.addEventListener('click', async () => {

    if (!recognizing) {

      const ok = await ensureMic();

      if (!ok) return;

      await keepAwake(true);

      startRec();

    } else {

      await keepAwake(false);

      stopRec();

    }

  });



  clearBtn.addEventListener('click', () => { hist.textContent = ''; sentenceBuf=''; });



  copyBtn.addEventListener('click', async () => {

    try {

      await navigator.clipboard.writeText(hist.textContent);

      state.textContent = 'ë³µì‚¬ë¨'; setTimeout(()=> state.textContent = recognizing ? 'ì¸ì‹ ì¤‘' : 'ëŒ€ê¸°', 800);

    } catch { alert('ë³µì‚¬ ì‹¤íŒ¨: ê¶Œí•œ í™•ì¸'); }

  });



  saveBtn.addEventListener('click', () => {

    const blob = new Blob([hist.textContent], {type:'text/plain;charset=utf-8'});

    const a = document.createElement('a');

    a.href = URL.createObjectURL(blob);

    const dt = new Date().toISOString().replace(/[:.]/g,'-');

    a.download = `subtitle-inline-${dt}.txt`;

    a.click();

    URL.revokeObjectURL(a.href);

  });



  fsSel.addEventListener('change', () => { hist.style.fontSize = fsSel.value + 'px'; });

  hist.style.fontSize = fsSel.value + 'px';

})();

</script>

</body>

</html>