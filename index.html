<!doctype html>

<html lang="ko">

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>ì‹¤ì‹œê°„ í•œêµ­ì–´ ìë§‰ (ë³´ì • í•„í„°)</title>

  <style>

    :root { --fs: 22px; }

    body { margin:0; background:#111; color:#eee; font:var(--fs)/1.6 "Noto Sans KR",sans-serif; }

    header { padding:10px; border-bottom:1px solid #444; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    button { padding:6px 14px; border-radius:6px; border:none; cursor:pointer; font-weight:600; }

    button.primary { background:#4da3ff; color:#000; }

    button.danger  { background:#ff4d6d; color:#000; }

    #screen { padding:12px; height:80vh; overflow-y:auto; white-space:pre-wrap; }

    #state { margin-left:auto; color:#aaa; }

  </style>

</head>

<body>

  <header>

    <button id="toggle" class="primary">ğŸ™ï¸ ì‹œì‘</button>

    <button id="clear">ğŸ§¹ ì§€ìš°ê¸°</button>

    <button id="copy">ğŸ“‹ ë³µì‚¬</button>

    <span id="state">ëŒ€ê¸°</span>

  </header>



  <div id="screen"></div>



<script>

(() => {

  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;

  if (!Rec) {

    document.body.innerHTML = "<p style='padding:16px'>âŒ í¬ë¡¬/ì‚¼ì„± ì¸í„°ë„· ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤í–‰í•´ì£¼ì„¸ìš”.</p>";

    return;

  }



  const r = new Rec();

  r.lang = "ko-KR";

  r.continuous = true;

  r.interimResults = true;



  const toggle = document.getElementById("toggle");

  const clearBtn= document.getElementById("clear");

  const copyBtn = document.getElementById("copy");

  const state   = document.getElementById("state");

  const screen  = document.getElementById("screen");



  let recognizing = false;



  // append-only í…ìŠ¤íŠ¸

  const tape = document.createTextNode("");

  screen.appendChild(tape);



  let currentStream = "";

  let queuedDelta = "";



  const THROTTLE_MS = 380;

  let lastFlushAt = 0, flushTimer = null;



  // ===== ë³´ì • í•¨ìˆ˜ë“¤ =====

  // ë°˜ë³µ ë‹¨ì–´ ì œê±°: ê°™ì€ ë‹¨ì–´ê°€ ì—°ì† ë‘ ë²ˆ ë‚˜ì˜¤ë©´ í•˜ë‚˜ë§Œ ë‚¨ê¹€

  function dedupeWords(text) {

    return text.replace(/\b(\S+)\s+\1\b/g, "$1");

  }



  // ê°„ë‹¨ ë„ì–´ì“°ê¸° ë³´ì •: ì¡°ì‚¬/ì–´ë¯¸ì— ë¶™ì€ ë¶ˆí•„ìš”í•œ ê³µë°± ì •ë¦¬

  function fixSpacing(text) {

    return text

      .replace(/\s+([.,!?])/g, "$1")   // ë¬¸ì¥ë¶€í˜¸ ì• ê³µë°± ì œê±°

      .replace(/\s{2,}/g, " ");        // ì—°ì† ê³µë°± â†’ í•˜ë‚˜ë¡œ

  }



  function normalize(text) {

    return fixSpacing(dedupeWords(text));

  }



  function commonPrefixLen(a,b){

    const n = Math.min(a.length, b.length);

    let i=0;

    while (i<n && a.charCodeAt(i)===b.charCodeAt(i)) i++;

    return i;

  }



  function scheduleAppendFrom(newStream){

    const cpl = commonPrefixLen(currentStream, newStream);

    let delta = newStream.slice(cpl);

    if (!delta) return;



    // ë³´ì • ì ìš©

    delta = normalize(delta);



    queuedDelta += delta;



    const now = performance.now();

    const due = Math.max(0, THROTTLE_MS - (now - lastFlushAt));

    if (!flushTimer) flushTimer = setTimeout(flush, due);

    currentStream = newStream;

  }



  function flush(){

    if (queuedDelta) {

      tape.data += queuedDelta;

      screen.scrollTop = screen.scrollHeight;

      queuedDelta = "";

    }

    lastFlushAt = performance.now();

    flushTimer = null;

  }



  r.onresult = (e) => {

    let latestInterim = null;

    let gotFinal = false;



    for (let i=e.resultIndex; i<e.results.length; i++){

      const seg = e.results[i][0].transcript;

      if (e.results[i].isFinal) {

        gotFinal = true;

      } else {

        latestInterim = (latestInterim??"") + seg;

      }

    }



    if (latestInterim !== null) {

      scheduleAppendFrom(latestInterim);

    }

    if (gotFinal) currentStream = "";

  };



  r.onstart = () => { state.textContent="ğŸ¤ ì¸ì‹ ì¤‘"; toggle.textContent="â¸ï¸ ì¤‘ì§€"; toggle.className="danger"; };

  r.onend = () => {

    if (recognizing) { try { r.start(); } catch {} }

    else { state.textContent="ëŒ€ê¸°"; toggle.textContent="ğŸ™ï¸ ì‹œì‘"; toggle.className="primary"; }

  };



  toggle.onclick = async () => {

    if (!recognizing) {

      try { const s = await navigator.mediaDevices.getUserMedia({audio:true}); s.getTracks().forEach(t=>t.stop()); }

      catch { alert("ë§ˆì´í¬ ê¶Œí•œ í•„ìš”"); return; }

      recognizing = true; r.start();

    } else { recognizing = false; r.stop(); }

  };



  clearBtn.onclick = () => { tape.data=""; currentStream=""; queuedDelta=""; if (flushTimer){clearTimeout(flushTimer); flushTimer=null;} };

  copyBtn.onclick  = async () => {

    try { await navigator.clipboard.writeText(tape.data); state.textContent="ë³µì‚¬ë¨"; setTimeout(()=>state.textContent=recognizing?"ğŸ¤ ì¸ì‹ ì¤‘":"ëŒ€ê¸°",900); }

    catch { alert("ë³µì‚¬ ì‹¤íŒ¨"); }

  };

})();

</script>

</body>

</html>